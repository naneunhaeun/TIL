# 🗂️ TIL (Today I Learned)
📅 2025.09.08 월요일  

---

## 📌 오늘 배운 내용 정리

### 🔹 부분집합 (Powerset)

- **정의**: 어떤 집합의 공집합과 자기자신을 포함한 모든 부분 집합  
- 원소 개수가 `n`개일 때, 부분집합의 개수는 `2^n`

#### 부분집합 구현 방법
1. **완전탐색 (Brute Force)**
   - 재귀 호출을 이용
   - 학습용으로 적합, 실전에서는 비효율적
2. **Binary Counting (이진수 & 비트 연산)**
   - 비트마스크로 부분집합 표현
   - 원소가 많을 때도 효율적이며 모든 부분집합을 빠르게 구할 수 있음  

```python
arr = ['A', 'B', 'C']
n = len(arr)

def get_sub(tar):
    for i in range(n):
        # 비트 연산임을 명시하기 위해 0x1 사용
        if tar & 0x1:  # 가장 우측 비트를 체크
            print(arr[i], end='')
        tar >>= 1
    print()

# 예시: {B, C} → 0b110 = 6
get_sub(6)  # 출력: BC
```

👉 `2^n`은 `1 << n`으로도 구할 수 있음  
```python
print(pow(2,3)) # 8
print(1<<3)     # 8
```

---

### 🔹 조합 (Combination)

- **정의**: 서로 다른 `n`개의 원소 중 `r`개를 순서 없이 고른 것  
- 공식:  
  \[
  nCr = \frac{n!}{r!(n-r)!}
  \]

예시: {A, B, C}에서 2개를 뽑는 경우 → `{A,B}, {A,C}, {B,C}`

---

### 🔹 탐욕 알고리즘 (Greedy)

- **정의**: 매 순간 기준에서 가장 좋아 보이는 선택을 하는 알고리즘  
- 특징:
  - 매 단계에서 "최선"을 선택
  - 전체 최적해를 보장하지는 않음 (문제에 따라 다름)
- 활용 예시:
  - 거스름돈 문제
  - 회의실 배정 문제
  - 최소 신장 트리 (MST, Kruskal, Prim)

---

## 📖 오늘의 배움 & 느낀 점
- 부분집합을 **재귀와 비트 연산** 두 방식으로 구현할 수 있음을 배움  
- `1 << n`을 이용하면 `2^n`을 빠르게 구할 수 있다는 점이 신기했음  
- 탐욕 알고리즘은 항상 최적해를 보장하지 않으므로, 문제 특성을 잘 파악해야 함을 깨달음  
- 단순히 코드를 외우는 것이 아니라, **왜 그렇게 동작하는지**를 이해하는 게 중요하다고 느낌  

---
